package ping

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"unsafe"

	"net"
	"os"

	"golang.org/x/net/icmp"
	"golang.org/x/net/ipv4"
	"golang.org/x/net/ipv6"
	"golang.org/x/sys/unix"
)

// newConn returns a new udp connection with given local and destination addresses.
// laddr should be a valid IP address, while dst could be nil.
// Non-nil dst means that ICMP packets could be sent to and received from
// only given address, pinging different address would result in error.
func newConn(family, proto int, laddr *net.UDPAddr, dst net.IP) (conn net.PacketConn, err error) {
	s, err := unix.Socket(family, unix.SOCK_DGRAM|unix.SOCK_CLOEXEC, proto)
	if err != nil {
		return nil, os.NewSyscallError("socket", err)
	}

	if err := unix.Bind(s, sockaddr(laddr)); err != nil {
		unix.Close(s)
		return nil, os.NewSyscallError("bind", err)
	}

	if dst != nil {
		if err := unix.Connect(s, sockaddr(&net.UDPAddr{IP: dst})); err != nil {
			unix.Close(s)
			return nil, os.NewSyscallError("connect", err)
		}
	}

	f := os.NewFile(uintptr(s), "datagram-oriented icmp")
	c, err := net.FilePacketConn(f)
	if cerr := f.Close(); cerr != nil {
		return nil, cerr
	}
	return c, err
}

// rLock locks for reading and makes all pending requests return an error
func (p *Pinger) rLock() error {
	return p.c.SetReadDeadline(time.Now())
}

// rUnlock unlocks for readling
func (p *Pinger) rUnlock() error {
	return p.c.SetReadDeadline(time.Time{})
}

// sendSeq sends an ICMP Echo Request with given sequence number to given destination.
// opts can be used to ste per-packet sendmsg(2) options.
func (p *Pinger) sendSeq(seq uint16, dst net.IP, payload []byte, opts ...WOption) error {
	var typ icmp.Type
	switch p.proto {
	case unix.IPPROTO_ICMP:
		typ = ipv4.ICMPTypeEcho
	case unix.IPPROTO_ICMPV6:
		typ = ipv6.ICMPTypeEchoRequest
	}
	b, err := (&icmp.Message{
		Type: typ,
		Body: &icmp.Echo{
			// ID is chosen by kernel, thanks to unix.IPPROTO_ICMP(V6)
			Seq:  int(seq),
			Data: payload,
		},
	}).Marshal(nil)
	if err != nil {
		return fmt.Errorf("marshal ICMP: %w", err)
	}

	oob := marshalOpts(opts...)
	sa := sockaddr(&net.UDPAddr{IP: dst})
	var operr error
	if err := p.rc.Write(func(s uintptr) (done bool) {
		operr = unix.Sendmsg(int(s), b, oob, sa, 0)
		if operr == nil {
			// syscall.RawConn.Write locks for writing, so we are sure
			// that optID generated by unix.SOF_TIMESTAMPING_OPT_ID
			// matches current ICMP sequence number.
			p.optIDs.now(seq)
		}
		return !errIsWouldBlockOr(operr)
	}); err != nil {
		return err
	}
	return os.NewSyscallError("sendmsg", operr)
}

// Listen handles receiving of incomming replies and routes them into calling
// Pinger.Ping* method, so *no* Pinger.Ping*() methods should be called before
// Listen and after it returns.
//
// msgBuffSize is a size of buffer for socket messages for receiving incoming packets.
// maxPayloadSize is a maximum size of ICMP payload to receive.
//
// NOTE: It is a blocking call, so it should be run as a separate goroutine.
// It returns a non-nil error if context is done or an error occured
// while receiving on sokcet.
func (p *Pinger) Listen(ctx context.Context) error {
	if err := p.rUnlock(); err != nil {
		return err
	}
	ctx, cancel := context.WithCancel(ctx)
	var g sync.WaitGroup
	defer g.Wait()
	g.Add(1)
	go func() {
		defer g.Done()

		<-ctx.Done()
		_ = p.rLock()
	}()
	defer cancel()

	err := p.read()
	if errors.Is(err, os.ErrDeadlineExceeded) {
		err = ctx.Err()
	}
	return err
}

const (
	sizeOfICMPEchoHeader = unsafe.Sizeof(struct {
		typ      uint8
		code     uint8
		checksum uint16
		echo     struct {
			id  uint16
			seq uint16
		}
	}{})
)

func (p *Pinger) read() error {
	buff := make([]byte, p.mtu-int32(sizeOfICMPEchoHeader))
	oob := make([]byte, unix.CmsgSpace(int(unsafe.Sizeof(unix.ScmTimestamping{})))+
		unix.CmsgSpace(int(TTL(0).Len())))
	errQueueBuff := make([]byte, sizeOfICMPEchoHeader) // we are not interested in ICMP payload
	errQueueOOB := make([]byte, len(oob)+
		unix.CmsgSpace(int(unsafe.Sizeof(unix.SockExtendedErr{})+
			unsafe.Sizeof(unix.RawSockaddrInet6{}))))

	var (
		n, oobn, errQueueN, errQueueOOBN int
		operr, errQueueOperr             error
	)
	for {
		if err := p.rc.Read(func(s uintptr) (done bool) {
			// TODO: recvmmsg
			n, oobn, _, _, operr = unix.Recvmsg(int(s), buff, oob, unix.MSG_DONTWAIT)
			errQueueN, errQueueOOBN, _, _, errQueueOperr = unix.Recvmsg(
				int(s), errQueueBuff, errQueueOOB, unix.MSG_ERRQUEUE|unix.MSG_DONTWAIT)
			return !(errIsWouldBlockOr(operr) && errIsWouldBlockOr(errQueueOperr))
		}); err != nil {
			return err
		}
		// TODO: copy buffs
		if errQueueOperr == nil {
			scms, err := unix.ParseSocketControlMessage(errQueueOOB[:errQueueOOBN])
			if err != nil {
				return fmt.Errorf("parse socket control messages: %w", err)
			}
			p.dispatch(errQueueBuff[:errQueueN], scms)
		} else if !errIsWouldBlockOr(errQueueOperr) {
			return os.NewSyscallError("recvmsg", errQueueOperr)
		}

		if operr == nil {
			scms, err := unix.ParseSocketControlMessage(oob[:oobn])
			if err != nil {
				return fmt.Errorf("parse socket control messages: %w", err)
			}
			p.dispatch(buff[:n], scms)
		} else if !errIsWouldBlockOr(operr, unix.EHOSTUNREACH) {
			return os.NewSyscallError("recvmsg", operr)
		}
	}
}

// dispatch extracts
//   * ICMP reply or ICMP error from given recvmsg(2) buffer and
//     socket control messages and dispatches them to the sender
//   * transmit timestamp and updates corresponding pending request
func (p *Pinger) dispatch(buff []byte, scms []unix.SocketControlMessage) {
	var (
		icmpErr       ICMPError
		ttl           uint8
		ts            time.Time
		isTxTimestamp bool
		optID         uint32
	)
	for _, scm := range scms {
		switch scm.Header.Level {
		case unix.SOL_IP, unix.SOL_IPV6:
			switch scm.Header.Type {
			case unix.IP_RECVERR, unix.IPV6_RECVERR:
				se := (*unix.SockExtendedErr)(unsafe.Pointer(&scm.Data[0]))
				switch se.Origin {
				case unix.SO_EE_ORIGIN_TIMESTAMPING:
					if unix.Errno(se.Errno) != unix.ENOMSG ||
						se.Info != unix.SCM_TSTAMP_SCHED {
						continue
					}
					isTxTimestamp = true
					optID = se.Data // unix.SOF_TIMESTAMPING_OPT_ID
				case unix.SO_EE_ORIGIN_ICMP:
					if unix.Errno(se.Errno) != unix.EHOSTUNREACH {
						continue
					}
					sa := (*unix.RawSockaddrInet4)(unsafe.Pointer(&scm.Data[unsafe.Sizeof(*se)]))
					switch se.Type {
					case uint8(ipv4.ICMPTypeDestinationUnreachable):
						icmpErr = NewDestinationUnreachableError(sa.Addr[:],
							DstUnreachableCode(se.Code))
					case uint8(ipv4.ICMPTypeTimeExceeded):
						icmpErr = NewTimeExceededError(sa.Addr[:])
					}
				case unix.SO_EE_ORIGIN_ICMP6:
					if unix.Errno(se.Errno) != unix.EHOSTUNREACH {
						continue
					}
					sa := (*unix.RawSockaddrInet6)(unsafe.Pointer(&scm.Data[unsafe.Sizeof(*se)]))
					switch se.Type {
					case uint8(ipv6.ICMPTypeDestinationUnreachable):
						icmpErr = NewDestinationUnreachableError(sa.Addr[:],
							DstUnreachableCode(se.Code))
					case uint8(ipv6.ICMPTypeTimeExceeded):
						icmpErr = NewTimeExceededError(sa.Addr[:])
					}
				}
			case unix.IP_TTL, unix.IPV6_HOPLIMIT:
				ttlOpt := TTL(0)
				ttlOpt.Unmarshal(scm.Data)
				ttl = ttlOpt.Get()
			}
		case unix.SOL_SOCKET:
			switch scm.Header.Type {
			case unix.SCM_TIMESTAMPING:
				ts = time.Unix((*unix.ScmTimestamping)(unsafe.Pointer(&scm.Data[0])).Ts[0].Unix())
			}
		}
	}
	if isTxTimestamp {
		p.seqs.sentAt(p.optIDs.pop(optID), ts)
		return
	}
	msg, err := icmp.ParseMessage(p.proto, buff)
	if err != nil {
		return
	}
	echo, ok := msg.Body.(*icmp.Echo)
	if !ok {
		return
	}
	p.seqs.reply(uint16(echo.Seq), ts, echo.Data, ttl, icmpErr)
}

// sockaddr converts *net.UDPAddr to syscall.Sockaddr
func sockaddr(addr *net.UDPAddr) unix.Sockaddr {
	if ip := addr.IP.To4(); ip != nil {
		sa := unix.SockaddrInet4{
			Port: addr.Port,
		}
		copy(sa.Addr[:], ip)
		return &sa
	} else if ip = addr.IP.To16(); ip != nil {
		sa := unix.SockaddrInet6{
			Port: addr.Port,
		}
		copy(sa.Addr[:], addr.IP.To16())
		return &sa
	}
	return nil
}

// errIsWouldBlockOr returns whether given error denotes blocking operation
// or is one of errs
func errIsWouldBlockOr(err error, errs ...error) bool {
	return errIsOneOf(err, append(errs, unix.EAGAIN, unix.EWOULDBLOCK)...)
}

// errIsOneOf returns whether given error is one of errs
func errIsOneOf(err error, errs ...error) bool {
	for _, e := range errs {
		if errors.Is(err, e) {
			return true
		}
	}
	return false
}
